package org.ektorpmock.impl;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.*;
import org.apache.commons.io.IOUtils;
import org.ektorp.*;
import org.ektorp.changes.ChangesCommand;
import org.ektorp.changes.ChangesFeed;
import org.ektorp.changes.DocumentChange;
import org.ektorp.http.HttpClient;
import org.ektorp.impl.*;
import org.ektorp.support.DesignDocument;
import org.ektorp.support.Revisions;
import org.ektorp.util.Assert;
import org.ektorp.util.Base64;
import org.ektorp.util.Documents;
import org.ektorpmock.ViewEvaluator;
import java.io.IOException;
import java.io.InputStream;
import java.util.*;

public class InMemoryCouchDbConnector implements CouchDbConnector {

    private final ObjectMapper objectMapper;
    private JsonSerializer jsonSerializer;
    private ViewEvaluator viewEvaluator;
    private int revisionLimit;
    private long updateSequence = 0;
    private long documentDeleteCount = 0;

    private final ThreadLocalBulkBufferHolder bulkBufferManager = new ThreadLocalBulkBufferHolder();

    private Map<String, String> data;
    private Map<String, Revisions> revisions;
    private Map<String, Map<String, String>> revisionMap;


    InMemoryCouchDbConnector() {
        this(new StdObjectMapperFactory());

    }

    InMemoryCouchDbConnector(ViewEvaluator ve) {
        this(new StdObjectMapperFactory());
        this.viewEvaluator = ve;
    }

    InMemoryCouchDbConnector(ObjectMapperFactory omf) {
        Assert.notNull(omf, "ObjectMapperFactory may not be null");
        this.objectMapper = omf.createObjectMapper(this);
        this.jsonSerializer = new StreamingJsonSerializer(objectMapper);
        data = new LinkedHashMap<String, String>();
        revisions = new LinkedHashMap<String, Revisions>();
        revisionMap = new LinkedHashMap<String, Map<String,String>>();
    }
    /**
     *
     * @param id
     * @param o
     *            object to store in the database
     * @throws org.ektorp.UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public void create(String id, Object o) {
        if (contains(id)) {
            if (id.equals(Documents.getId(o))) {
                update(o);
                return;
            } else {
                throw new UpdateConflictException();
            }
        }
        String revision = incrementRevision(null);
        Documents.setRevision(o, revision);
        String json = jsonSerializer.toJson(o);
        data.put(id, json);
        List<String> ids = new ArrayList<String>();
        ids.add(id);
        revisions.put(id, new Revisions(1, ids));
        Map<String, String> revisionMapEntry = new LinkedHashMap<String, String>();
        revisionMapEntry.put(revision, json);
        revisionMap.put(id, revisionMapEntry);
        updateSequence++;
    }

    /**
     * Creates the Object as a document in the database. If the id is not set it will be generated by the database.
     *
     * The Object's revision field will be updated through the setRevision(String s) method.
     *
     * @param o
     * @throws UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public void create(Object o) {
        Assert.notNull(o, "Document may not be null");
        Assert.isTrue(Documents.isNew(o), "Object must be new");

        String id = Documents.getId(o);
        if (id != null) {
            create(id, o);
        } else {
            id = UUID.randomUUID().toString();
            Documents.setId(o, id);
            create(id, o);
        }
    }

    /**
     * Updates the document.
     *
     * The Object's revision field will be updated through the setRevision(String s) method.
     *
     * @param o
     * @throws UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public void update(Object o) {
        String id = Documents.getId(o);
        if (id == null) {
            throw new IllegalArgumentException("id can not be empty");
        }
        _update(o);
    }

    /**
     * Sends a document to the Couch server as a JSON stream
     * @param id the document ID
     * @param document an InputStream of the JSON document
     * @param length the length of the JSON document
     * @param options options to pass to the Couch request
     */
    @Override
    public void update(String id, InputStream document, long length, Options options) {
        if (id == null) {
            throw new IllegalArgumentException("id can not be empty");
        }

        try {
            JsonNode jsonNode = objectMapper.readTree(document);
            Documents.setId(jsonNode, id);
            _update(jsonNode);
        }
        catch (JsonProcessingException processingException) {}
        catch (IOException ioException) {}
    }

    private void _update(Object o) {
        if (shouldDelete(o)) {
            try {
                delete(o);
            } catch (DocumentNotFoundException dnfe) {
//                couchdb does not seem to return an error in this scenario.
            }
            return;
        }
        String id = Documents.getId(o);
        String revision = Documents.getRevision(o);
        if (revision == null) {
            create(o);
            return;
        }
        if (documentOutOfDate(o)) {
            throw new UpdateConflictException(id, Documents.getRevision(o));
        }
        String newRevision = incrementRevision(revision);
        Documents.setRevision(o, newRevision);
        String json = jsonSerializer.toJson(o);
        data.put(id, json);
        Revisions oldRevisions = revisions.get(id);
        List<String> ids = new ArrayList<String>();
        ids.add(id);
        ids.addAll(oldRevisions.getIds());
        revisions.put(id, new Revisions((long)revisionToInt(newRevision), ids));
        revisionMap.get(id).put(newRevision, json);
        updateSequence++;
    }

    /**
     * Deletes the Object in the database.
     *
     * @param o
     * @return the revision of the deleted document
     * @throws UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public String delete(Object o) {
        Assert.notNull(o, "Document cannot be null");
        return delete(Documents.getId(o), Documents.getRevision(o));
    }

    /**
     * Deletes the document in the database.
     *
     * @param id
     * @param revision
     * @return the revision of the deleted document.
     * @throws UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public String delete(String id, String revision) {
        Assert.hasText(id, "document id cannot be empty");
        if (!contains(id)) {
            throw new DocumentNotFoundException(id);
        }
        String o = data.get(id);
        HashMap map = new HashMap();
        try {
            map = objectMapper.readValue(o, HashMap.class);
        } catch (JsonMappingException jsonMappingException) {}
        catch (JsonParseException jsonParseException) {}
        catch (IOException ioException) {}
        String currentRevision = Documents.getRevision(map);
        if ((revisionToInt(revision)) != revisionToInt(currentRevision)) {
            throw new UpdateConflictException(id, revision);
        }
        data.remove(id);
        documentDeleteCount++;
        updateSequence++;
        return incrementRevision(currentRevision);
    }

    /**
     * Copies a document to the target document id.
     * Useful when you want to duplicate docs with large attachments.
     *
     * @param sourceDocId
     * @param targetDocId
     * @return revision of the target document.
     */
    @Override
    public String copy(String sourceDocId, String targetDocId) {
        if (contains(targetDocId)) {
            throw new UpdateConflictException();
        }
        InputStream sourceDoc = getAsStream(sourceDocId);
        JsonNode jsonNode;

        try {
            jsonNode = objectMapper.readTree(sourceDoc);
            Documents.setId(jsonNode, targetDocId);
            data.put(targetDocId, jsonNode.toString());
            revisions.put(targetDocId, new Revisions(1, Collections.singletonList(targetDocId)));
            Map<String, String> revisionMapEntry = new LinkedHashMap<String, String>();
            revisionMapEntry.put(targetDocId, jsonNode.toString());
            revisionMap.put(targetDocId, revisionMapEntry);
            return Documents.getRevision(jsonNode);
        } catch (JsonParseException jsonParseException) {}
        catch (IOException ioException) {}
        return null;
    }

    /**
     *
     * Copies a document and overwrites the target document.
     * Useful when you want to duplicate docs with large attachments.
     *
     * @param sourceDocId
     * @param targetDocId
     * @param targetRevision
     * @return revision of the target document.
     */
    @Override
    public String copy(String sourceDocId, String targetDocId, String targetRevision) {
        InputStream sourceDoc = getAsStream(sourceDocId);

        try {
            update(targetDocId, sourceDoc, (long)sourceDoc.available(), new Options().revision(targetRevision));
        } catch (IOException ioException) {}

        List<Revision> revisions = getRevisions(targetDocId);
        Revision lastRevision = revisions.get(revisions.size() - 1);
        return lastRevision.getRev();
    }

    @Override
    public PurgeResult purge(Map<String, java.util.List<String>> revisionsToPurge) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    /**
     *
     * @param <T>
     * @param c
     *            the target class to map to.
     * @param id
     *            the id of the document in the database.
     * @return the document mapped as the specified class.
     * @throws org.ektorp.DocumentNotFoundException
     *             if the document was not found.
     */
    @Override
    public <T> T get(Class<T> c, String id) {
        return get(c, id, new Options());
    }

    /**
     *
     * @param c
     *            the target class to map to.
     * @param id
     *            the id of the document in the database.
     * @param options
     * @return the document mapped as the specified class.
     * @throws DocumentNotFoundException
     *             if the document was not found.
     */
    @Override
    public <T> T get(Class<T> c, String id, Options options) {
        String json = getJsonString(id, options);
        try {
            return objectMapper.readValue(json, c);
        } catch (JsonMappingException jsonMappingException) {
            return null;
        } catch (JsonParseException psonParseException) {
            return null;
        } catch (IOException ioException) {
            return null;
        }
    }

    /**
     * Same as get(Class<T> c, String id) with the difference that null is return if the document was not found.
     *
     * @param c
     * @param id
     * @return null if the document was not found.
     */
    @Override
    public <T> T find(Class<T> c, String id) {
        return find(c, id, new Options());
    }

    /**
     * Same as get(Class<T> c, String id, Options options) with the difference that null is return if the document was
     * not found.
     *
     * @param c
     * @param id
     * @param options
     * @return null if the document was not found.
     */
    @Override
    public <T> T find(Class<T> c, String id, Options options) {
        try {
            get(c, id);
        } catch (DocumentNotFoundException dnfe) {
        }
        return null;
    }

    @Override
    @Deprecated
    public <T> T get(Class<T> c, String id, String rev) {
        return get(c, id, new Options().revision(rev));
    }

    @Override
    @Deprecated
    public <T> T getWithConflicts(Class<T> c, String id) {
        return get(c, id, new Options().includeConflicts());
    }

    /**
     * Check if the database contains a document.
     *
     * @param id
     * @return true if a document with the id exists in the database
     */
    @Override
    public boolean contains(String id) {
        return data.containsKey(id);
    }

    /**
     * Please note that the stream has to be closed after usage, otherwise http connection leaks will occur and the
     * system will eventually hang due to connection starvation.
     *
     * @param id
     * @return the document as raw json in an InputStream, don't forget to close the stream when finished.
     * @throws DocumentNotFoundException
     *             if the document was not found.
     */
    @Override
    public InputStream getAsStream(String id) {
        return getAsStream(id, new Options());
    }

    @Override
    @Deprecated
    public InputStream getAsStream(String id, String rev) {
        return getAsStream(id, new Options().revision(rev));
    }

    @Override
    public InputStream getAsStream(String id, Options options) {
        String json = getJsonString(id, options);
        return IOUtils.toInputStream(json);
    }

    @Override
    public List<Revision> getRevisions(String id) {
        List<Revision> revs = new ArrayList<Revision>();
        List<String> stringRevisions = new ArrayList<String>(revisionMap.get(id).keySet());
        Collections.sort(stringRevisions, new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return new Integer(revisionToInt(s1)).compareTo(revisionToInt(s2));
            }
        });

        for (String stringRevision: stringRevisions) {
            revs.add(new Revision(stringRevision, "ok"));
        }

        return revs;
    }

    @Override
    public AttachmentInputStream getAttachment(String id, String attachmentId) {
        return getAttachment(id, attachmentId, null);
    }

    @Override
    public AttachmentInputStream getAttachment(String id, String attachmentId, String revision) {
        String json = getJsonString(id, new Options());
        try {
            JsonNode map = objectMapper.readValue(json, JsonNode.class);
            JsonNode attachmentsMap = map.get("_attachments");
            JsonNode attachmentMap = attachmentsMap.get(attachmentId);
            String attachmentString = jsonSerializer.toJson(attachmentMap);
            Attachment attachment = null;
            attachment = objectMapper.readValue(attachmentString, Attachment.class);
            String data = (attachment.getDataBase64() != null) ? attachment.getDataBase64() : (String)attachment.getAnonymous().get("data");
            return new AttachmentInputStream(attachmentId, IOUtils.toInputStream(new String(Base64.decode(data))), attachment.getContentType());
        } catch (JsonMappingException jsonMappingException) {}
        catch (JsonParseException jsonParseException) {}
        catch (IOException ioException) {}
        return null;
    }

    /**
     * Creates both the document and the attachment
     *
     * @param docId
     * @param data
     *            - the data to be saved as an attachment
     * @return revision of the created attachment document
     * @throws UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public String createAttachment(String docId, AttachmentInputStream data) {
        return createAttachment(docId, null, data);
    }

    /**
     * Adds an attachment to the specified document id.
     *
     * @param docId
     * @param revision
     * @param stream
     *            - the data to be saved as an attachment
     * @return the new revision of the document
     * @throws UpdateConflictException
     *             if there was an update conflict.
     */
    @Override
    public String createAttachment(String docId, String revision, AttachmentInputStream stream) {
        String json;
        try {
            json = getJsonString(docId, new Options());
        } catch (DocumentNotFoundException dnfe) {
            json = jsonSerializer.toJson(Collections.singletonMap("_id", docId));
        }

        ObjectNode map = new ObjectNode(JsonNodeFactory.instance);
        try {
            map = objectMapper.readValue(json, ObjectNode.class);
        } catch (Exception ex) {
            System.out.println("There's gonna be problems");
            ex.printStackTrace();
        }

        if ((revision == null) && map.has("_rev")) {
            throw new UpdateConflictException();
        }
        if (!map.has("_attachments")) {
            map.set("_attachments", new ObjectNode(JsonNodeFactory.instance));
        }
        if ((map.get("_attachments")).has(stream.getId())) {
            throw new UpdateConflictException();
        }


        try {
            Attachment attachment = new Attachment(stream.getId(), Base64.encodeBytes(IOUtils.toString(stream).getBytes()), stream.getContentType());
            ((ObjectNode)map.get("_attachments")).set(stream.getId(), objectMapper.convertValue(attachment, JsonNode.class));
        } catch (IOException ioException) {}
        map.put("_rev", incrementRevision(map.has("_rev") ? map.get("_rev").asText() : null));
        json = jsonSerializer.toJson(map);
        data.put(docId, json);

        return map.get("_rev").asText();
    }

    @Override
    public String deleteAttachment(String docId, String revision, String attachmentId) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public List<String> getAllDocIds() {
        return new ArrayList<String>(data.keySet());
    }

    @Override
    public <T> List<T> queryView(ViewQuery query, Class<T> type) {
        List<T> rows = new ArrayList<T>();
        try {
            ViewResult viewResult = queryView(query);

            for(ViewResult.Row row: viewResult.getRows()) {
                rows.add(objectMapper.readValue(row.getDoc() != null ? row.getDoc() : "", type));
            }
        } catch (Exception ex) {
            throw new DbAccessException(ex);
        }
        return rows;
    }

    @Override
    public <T> Page<T> queryForPage(ViewQuery query, PageRequest pr, Class<T> type) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public ViewResult queryView(ViewQuery query) {
        try {
            String jsonData =  evaluateView(query);
            JsonNode node = objectMapper.readTree(jsonData);
            return new ViewResult(node, false);
        } catch (JsonProcessingException jsonProcessingException) {}
        catch (IOException ioException) {}
        return null;
    }

    @Override
    public StreamingViewResult queryForStreamingView(ViewQuery query) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public InputStream queryForStream(ViewQuery query) {
        String jsonData =  evaluateView(query);
        return IOUtils.toInputStream(jsonData);
    }

    @Override
    public void createDatabaseIfNotExists() {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public String getDatabaseName() {
        return Integer.toHexString(System.identityHashCode(this));
    }

    @Override
    public String path() {
        return this.getClass().getName();
    }

    @Override
    public HttpClient getConnection() {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public DbInfo getDbInfo() {
        ObjectNode objectNode = new ObjectNode(new JsonNodeFactory(false));
        objectNode.set("doc_count", new LongNode((long)data.size()));
        objectNode.set("update_seq", new TextNode(Long.toString(updateSequence)));
        objectNode.set("doc_del_count", new LongNode(documentDeleteCount));
        objectNode.set("db_name", new TextNode(getDatabaseName()));

        DbInfo dbInfo = objectMapper.convertValue(objectNode, DbInfo.class);
        return dbInfo;
    }

    /**
     * Obtains information about a given design document, including the index, index size and current status of the
     * design document and associated index information.
     *
     * @param designDocId
     * @return
     */
    @Override
    public DesignDocInfo getDesignDocInfo(String designDocId) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public void compact() {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public void compactViews(String designDocumentId) {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public void cleanupViews() {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public int getRevisionLimit() {
        return revisionLimit;
    }

    @Override
    public void setRevisionLimit(int limit) {
        revisionLimit = limit;
    }

    @Override
    public ReplicationStatus replicateFrom(String source) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public ReplicationStatus replicateFrom(String source, Collection<String> docIds) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public ReplicationStatus replicateTo(String target) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public ReplicationStatus replicateTo(String target, Collection<String> docIds) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    /**
     * Add the object to the bulk buffer attached to the executing thread. A subsequent call to either flushBulkBuffer
     * or clearBulkBuffer is expected.
     *
     * @param o
     */
    @Override
    public void addToBulkBuffer(Object o) {
        bulkBufferManager.add(o);
    }

    /**
     * Sends the bulk buffer attached the the executing thread to the database (through a executeBulk call). The bulk
     * buffer will be cleared when this method is finished.
     */
    @Override
    public List<DocumentOperationResult> flushBulkBuffer() {
        try {
            Collection<?> buffer = bulkBufferManager.getCurrentBuffer();
            if (buffer != null && !buffer.isEmpty()) {
                return executeBulk(buffer);
            } else {
                return Collections.emptyList();
            }
        } finally {
            clearBulkBuffer();
        }
    }

    /**
     * Clears the bulk buffer attached the the executing thread.
     */
    @Override
    public void clearBulkBuffer() {
        bulkBufferManager.clear();
    }

    @Override
    public List<DocumentOperationResult> executeBulk(InputStream inputStream) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public List<DocumentOperationResult> executeAllOrNothing(InputStream inputStream) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    /**
     * Creates, updates or deletes all objects in the supplied collection.
     *
     * If the object has no revision set, it will be created, otherwise it will be updated. If the object's serialized
     * json document contains a "_deleted"=true field it will be deleted.
     *
     * org.ektorp.BulkDeleteDocument.of(someObject) is the easiest way to create a delete doc for an instance.
     *
     * Some documents may successfully be saved and some may not. The response will tell the application which documents
     * were saved or not. In the case of a power failure, when the database restarts some may have been saved and some
     * not.
     *
     * @param objects
     *            , all objects will have their id and revision set.
     * @return The list will only contain entries for documents that has any kind of error code returned from CouchDB.
     *         i.e. the list will be empty if everything was completed successfully.
     */
    @Override
    public List<DocumentOperationResult> executeBulk(Collection<?> objects) {
        return _executeBulk(objects, false);
    }

    /**
     * Creates, updates or deletes all objects in the supplied collection. In the case of a power failure, when the
     * database restarts either all the changes will have been saved or none of them. However, it does not do conflict
     * checking, so the documents will be committed even if this creates conflicts.
     *
     * @param objects
     *            , all objects will have their id and revision set.
     * @return The list will only contain entries for documents that has any kind of error code returned from CouchDB.
     *         i.e. the list will be empty if everything was completed successfully.
     */
    @Override
    public List<DocumentOperationResult> executeAllOrNothing(Collection<?> objects) {
        return _executeBulk(objects, true);
    }

    private List<DocumentOperationResult> _executeBulk(Collection<?> objects,
                                                       boolean allOrNothing) {
        List<DocumentOperationResult> results = new ArrayList<DocumentOperationResult>();

        for (Object object: objects) {
            try {
                _update(object);
            } catch (UpdateConflictException uce) {
                if (!allOrNothing) {
                    results.add(DocumentOperationResult.newInstance(Documents.getId(object), "conflict", "Document update conflict."));
                }
            }
        }
        return results;
    }

    @Override
    public List<DocumentChange> changes(ChangesCommand cmd) {
        if (cmd.continuous) {
            throw new IllegalArgumentException(
                    "ChangesCommand may not declare continous = true while calling changes");
        }
        return null;
    }

    @Override
    public StreamingChangesResult changesAsStream(ChangesCommand cmd) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public ChangesFeed changesFeed(ChangesCommand cmd) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public String callUpdateHandler(String designDocID, String function, String docId) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public String callUpdateHandler(String designDocID, String function, String docId, Map<String, String> params) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public  <T> T callUpdateHandler(UpdateHandlerRequest req, Class<T> c) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public String callUpdateHandler(UpdateHandlerRequest req) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public void ensureFullCommit() {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public void updateMultipart(String id, InputStream stream, String boundary, long length, Options options) {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public String getCurrentRevision(String id) {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }
    /**
     * There must be a more efficient way to do this
     * @param query
     */
    private String evaluateView(ViewQuery query) {
        DesignDocument designDocument = get(DesignDocument.class, query.getDesignDocId());
        DesignDocument.View view = designDocument.getViews().get(query.getViewName());
        if (view == null) throw new DocumentNotFoundException(query.getDesignDocId() + "/" + query.getViewName());

        List viewList = viewEvaluator.evaluateView(view, query, new ArrayList(data.values()));

        int offset = Math.min(Math.max(query.getSkip(), 0), viewList.size());
        int max;
        if (query.getLimit() == -1) {
            max = viewList.size();
        } else {
            max = Math.min(viewList.size(), offset + query.getLimit());
        }
        Map resultsMap = new HashMap();

        resultsMap.put("rows", !viewList.isEmpty() ? viewList.subList(offset, max) : viewList);
        resultsMap.put("total_rows", viewList.size());
        resultsMap.put("offset", offset);

        if (query.isIncludeDocs()) {
            for (Map row: (List<Map>)resultsMap.get("rows")) {
                row.put("doc", data.get(row.get("id")));
            }
        }

        String jsonData = jsonSerializer.toJson(resultsMap);
        return jsonData;
    }

    private String getJsonString(String id, Options options) {
        if (!contains(id)) {
            throw new DocumentNotFoundException(id);
        }
        String json;
        String rev = options.getOptions().get("rev");
        if (rev != null) {
            json = revisionMap.get(id).get(rev);
            if (json == null) {
                throw new DocumentNotFoundException(id);
            }
        } else {
            json = data.get(id);
        }

        String getRevs = options.getOptions().get("revs");
        if (getRevs != null && getRevs.equals("true")) {
            Revisions revs = this.revisions.get(id);
            ObjectNode map = new ObjectNode(JsonNodeFactory.instance);
            try {
                map = objectMapper.readValue(json, ObjectNode.class);
            } catch (Exception ex) {}
            map.put("_revisions", objectMapper.convertValue(revs, ObjectNode.class));
            json = jsonSerializer.toJson(map);
        }
        return json;
    }

    private String incrementRevision(String oldRevision) {
        int oldRevisionInt = (oldRevision != null) ? (revisionToInt(oldRevision) + 1) : 1;
        return String.format("%s-%s", oldRevisionInt,UUID.randomUUID().toString());
    }

    private boolean documentOutOfDate(Object o) {
        String id = Documents.getId(o);
        String revision = Documents.getRevision(o);
        int revisionInt = revisionToInt(revision);

        JsonNode currentDoc = get(JsonNode.class, id);
        String currentRevision = Documents.getRevision(currentDoc);
        int currentRevisionInt = revisionToInt(currentRevision);

        return currentRevisionInt > revisionInt;
    }

    private int revisionToInt(String revision) {
        if (revision == null) return 0;
        return Integer.parseInt(revision.split("-")[0]);
    }

    private boolean shouldDelete(Object o) {
        JsonNode jsonNode = objectMapper.convertValue(o, JsonNode.class);
        if (jsonNode.has("_deleted")) {
            return jsonNode.get("_deleted").asBoolean();
        } else {
            return false;
        }

    }

}
